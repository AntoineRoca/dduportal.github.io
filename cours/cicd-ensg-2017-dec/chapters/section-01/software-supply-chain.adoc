
= CI / CD Pipelines

////
We need to revisit this section later.
////
== What is a CI/CD Pipeline ?

* Model of the value stream of your software production business
* Defines and models build, testing, and/or deployment processes as
continuous workflows
* Fundamental to achieving Continuous Delivery
** Continuous Delivery is necessary to achieve Continuous Deployment

== Why use a CI/CD Pipeline?

* Using a "CD Pipeline" gives same outcome as a value or supply chain in
other industries
** This model is easier to analyze and manage
* It is driven by the *fail-fast* concept
** "Fast is cheap": Pipeline detects failures as early as possible

== Anatomy of CI/CD Pipelines

* Composed of _stages_, mapped to atomic steps
** Scoped to cacheable result
** You should never have to rerun a successful step, just retrieve
the cached result
* Transition between 2 stages is a _gate_
** Manual or Automated
** A transition that confirms a requirement is met is a *Validation Gate*
** _gates_ trigger next stage
* Stages can be run sequentially and/or in parallel
** Thus _gates_ can branch and even be conditional
* Driven by atomic change: generally SCM single commit

== A CD Pipeline Example

image::{imagedir}/cd-pipeline-example.jpg[caption="A deployment Pipeline Example"]

////
Robert edited to here
////
== Deployment Stages of a CD Pipeline

* *Deployment* is the set of actions that makes a software system ready for usage
* Deploying software is done in *environments*
* Environments are isolated runtimes with specific properties:
** Production environments are where software lives for end users
** Testing environments are locations where tests are run against software
** Disaster Recovery Environment is an emergency location from which software
can be run after a disaster occurs on a production environment

== Automated Deployment

Using _automation_ for a deployment stage:

* Make deployment repeatable and less error-prone
* Bring ROI when deploying on new environment
* Make frequent releases possible by bringing _confidence_
* Still can require a manual (read: _human_) trigger to have validation gate

== How to do Good CD Pipelines ?

* Pipelines driven by 2 golden rules:
** Keep it Efficient
** Always build upon known and good foundations

== Keep Pipelines Efficient

image::{imagedir}/cd-pipeline-wait.jpg[caption="Waiting for the pipeline build",width=400]

* Try to parallelize the long-running steps:
** Distribute by default automated ones: build, tests...
** Manual steps should be tightly measured: Are they _really_ needed ?
* You can even make manual gates parallelized:
** Think it as a 1-N or N-1 relationship
** Each stage of the _N_ is a deployment to a different environment

== Distributing the Build Stage

* The _build_ stage:
** Fully automated stage.
** Automated Gates to trigger: event from the SCM (commit, merge, pull-request)
* Easy to distribute to be efficient:
** Parallelize builds of different target architectures or OSes (ARM, Windows, Android...)
** Parallelize builds on independents modules of your code before assembling (Map & Reduce)
** Unit and Integration tests are tied to the code: run them in parallel !

== Distributing the Deployment Stage

* The _deployment_ stage:
** Should be automated, but can be manual
** Gates can be manual or automated
* Easy to distribute the automated ones
* You can also distribute manual gate-based if they are on different environments

== An Optimized Pipeline Example

image::{imagedir}/cd-pipeline-optimized-example.png[caption="An optimized deployment Pipeline Example"]

== Always Build upon Good Foundations

* Introducing Binary reuse: _"Only Build Your Binaries Once"_
** Compiling again a given binary violates the efficiency rule,
(shorter build time)
** Ensure same version of codebase is used across the pipeline
** If the binary does not comply with "deployable" rule,
then it must fail a test
** Focus on failing-fast

== What did we learn ?

* CD Pipeline is a great way to achieve your journey to Continuous Delivery
* It is a model of your value stream mapping
* Keep your pipelines efficient by parallelizing
* Focus on failing-fast
* Reuse good pipeline runs

== Going further

Some recommended readings on this subject:

* http://devops.com/2014/07/29/continuous-delivery-pipeline/
* http://martinfowler.com/bliki/DeploymentPipeline.html
* http://www.informit.com/articles/article.aspx?p=1621865
* https://www.thoughtworks.com/insights/blog/architecting-continuous-delivery
